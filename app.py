from flask import Flask, request, jsonify, render_template, redirect, url_for, send_file
import os
import time
import json

from database import init_db, get_db
from routes import map_bp, flespi_bp
from services.reporting_service import start_daily_beacon_check_thread, generate_activity_report, generate_device_activity_report
from services.beacon_logic import format_samoa_time, latest_messages


app = Flask(__name__)
app.register_blueprint(map_bp)
app.register_blueprint(flespi_bp)


# ---- Render/Gunicorn bootstrap ----
# Gunicorn does NOT run the __main__ block, so we initialize here.
from config import DB_PATH, REPORTS_DIR, ACTIVITY_REPORTS_DIR
print(f"[startup] SQLite DB: {DB_PATH}")
print(f"[startup] Reports dir: {REPORTS_DIR}")
print(f"[startup] Activity reports dir: {ACTIVITY_REPORTS_DIR}")
init_db()

# Start background scheduler thread (daily beacon check / report runner)
# Keep gunicorn workers=1 to avoid duplicate threads.
if os.getenv("DISABLE_DAILY_BEACON_THREAD", "0") != "1":
    try:
        start_daily_beacon_check_thread()
    except Exception as e:
        print("[startup] Failed to start background thread:", e)



def samoa_iso_now() -> str:
    """Return current Samoa local time in ISO-like format YYYY-MM-DDTHH:MM:SS."""
    # Reuse the same Samoa conversion used everywhere else
    return format_samoa_time(time.time()).replace(" ", "T")


def build_beacon_alias_map(conn):
    """Return a mapping so old IDs and renamed beacons share one display label.

    Keys include both the raw beacon id and any friendly name; values are the
    unified label like "FriendlyName ‚Äì ID" (or just ID if no rename).
    """
    conn.execute(
        "CREATE TABLE IF NOT EXISTS beacon_names (id TEXT PRIMARY KEY, name TEXT)"
    )
    rows = conn.execute("SELECT id, name FROM beacon_names").fetchall()

    alias = {}
    for bid, bname in rows:
        if not bid:
            continue
        # Base label is either the friendly name or the id
        base_label = bname or bid
        if bname and bname != bid:
            label = f"{bname} ‚Äì {bid}"
        else:
            label = bid
        # Map both the raw id and the plain friendly name (if present)
        alias[bid] = label
        if bname:
            alias[bname] = label

    return alias

# ---- API for saving notifications ----

@app.route("/api/notifications", methods=["POST"])
def save_notification():
    """
    Store a single notification event in the database.

    Expected JSON (minimum):
      { "type": "...", "name": "...", "time": "...", "distance": <number|null> }

    Optional (preferred for stability):
      { "beacon_id": "...", "device_ident": "..." }

    Supported beacon types:
      - in / left  (one-time transition events)
      - still_in / still_out (status pings, throttled to 10 minutes per beacon+state)
    """
    data = request.get_json(silent=True) or {}
    ntype = (data.get("type") or "").strip()
    name = (data.get("name") or "").strip()
    event_time = (data.get("time") or "").strip() or None

    # Normalise distance
    distance = data.get("distance", None)
    try:
        distance = float(distance) if distance is not None else None
    except Exception:
        distance = None

    # Backwards compatibility: older frontend used type="status" with name like "X is still in range"
    if ntype == "status" and isinstance(name, str):
        lower = name.lower()
        if "still in range" in lower:
            ntype = "still_in"
            name = name.split(" is still")[0].strip()
        elif "still out of range" in lower:
            ntype = "still_out"
            name = name.split(" is still")[0].strip()

    if not ntype or not name:
        return jsonify({"status": "error", "message": "Invalid notification"}), 400

    # STILL status pings are generated by the cron evaluator (time-based), not by the browser.
    if ntype in ("still_in", "still_out"):
        return jsonify({"status": "ignored", "message": "still_* handled by cron"}), 202

    # Device online/offline are generated by telemetry + cron (server-side).
    if ntype in ("device_online", "device_offline"):
        return jsonify({"status": "ignored", "message": "device_* handled server-side"}), 202

    created_at = samoa_iso_now()
    now_ts = int(time.time())

    beacon_id = (data.get("beacon_id") or data.get("beaconId") or "").strip() or None
    device_ident = (data.get("device_ident") or data.get("deviceIdent") or "").strip() or None

    conn = get_db()

    # Ensure core tables exist
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            type TEXT,
            beacon_name TEXT,
            event_time TEXT,
            distance REAL,
            created_at TEXT,
            beacon_id TEXT,
            device_ident TEXT
        )
        """
    )
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS beacon_states (
            beacon_key TEXT PRIMARY KEY,
            state TEXT,
            last_change_ts INTEGER,
            last_still_ts INTEGER,
            device_ident TEXT,
            last_seen_ts INTEGER,
            active INTEGER
        )
        """
    )

    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS device_states (
            device_key TEXT PRIMARY KEY,
            state TEXT,
            last_change_ts INTEGER
        )
        """
    )

    # ---- Device state logic (prevents duplicate OFFLINE/ONLINE on refresh) ----
    DEVICE_TYPES = {"offline", "online"}
    if ntype in DEVICE_TYPES:
        device_key = (device_ident or name).strip()
        desired_state = "offline" if ntype == "offline" else "online"

        row = conn.execute(
            "SELECT state, last_change_ts FROM device_states WHERE device_key = ?",
            (device_key,),
        ).fetchone()

        # Only store when the state actually changes.
        if row and row[0] == desired_state:
            conn.close()
            return jsonify({"status": "ignored", "reason": "same_state"}), 200

        conn.execute(
            "INSERT INTO notifications (type, beacon_name, event_time, distance, created_at, beacon_id, device_ident) VALUES (?, ?, ?, ?, ?, ?, ?)",
            (ntype, name, event_time, distance, created_at, None, device_ident),
        )

        if row:
            conn.execute(
                "UPDATE device_states SET state = ?, last_change_ts = ? WHERE device_key = ?",
                (desired_state, now_ts, device_key),
            )
        else:
            conn.execute(
                "INSERT INTO device_states (device_key, state, last_change_ts) VALUES (?, ?, ?)",
                (device_key, desired_state, now_ts),
            )

        conn.commit()
        conn.close()
        return jsonify({"status": "ok"}), 201

    # ---- Beacon state logic ----
    BEACON_TYPES = {"in", "left", "still_in", "still_out"}
    if ntype in BEACON_TYPES:
        beacon_key = (beacon_id or name).strip()
        desired_state = "in" if ntype in ("in", "still_in") else "out"

        row = conn.execute(
            "SELECT state, last_change_ts, last_still_ts FROM beacon_states WHERE beacon_key = ?",
            (beacon_key,),
        ).fetchone()

        # Transition events: only store when the state actually changes.
        if ntype in ("in", "left"):
            if row and (row[0] == desired_state):
                conn.close()
                return jsonify({"status": "ignored", "reason": "same_state"}), 200

            conn.execute(
                "INSERT INTO notifications (type, beacon_name, event_time, distance, created_at, beacon_id, device_ident) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (ntype, name, event_time, distance, created_at, beacon_id, device_ident),
            )

            if row:
                conn.execute(
                    "UPDATE beacon_states SET state = ?, last_change_ts = ?, last_still_ts = NULL, device_ident = ?, last_seen_ts = ?, active = 1 WHERE beacon_key = ?",
                    (desired_state, now_ts, device_ident, now_ts, beacon_key),
                )
            else:
                conn.execute(
                    "INSERT INTO beacon_states (beacon_key, state, last_change_ts, last_still_ts, device_ident, last_seen_ts, active) VALUES (?, ?, ?, NULL, ?, ?, 1)",
                    (beacon_key, desired_state, now_ts, device_ident, now_ts),
                )

            conn.commit()
            conn.close()
            return jsonify({"status": "ok"}), 201

        # Status pings: store at most once every 10 minutes per beacon+state.
        # If backend thinks the beacon is in a different state, we update state but skip storing
        # a "still_*" ping to avoid false spam.
        else:
            if row and (row[0] != desired_state):
                conn.execute(
                    "UPDATE beacon_states SET state = ?, last_change_ts = ?, last_still_ts = NULL, device_ident = ?, last_seen_ts = ?, active = 1 WHERE beacon_key = ?",
                    (desired_state, now_ts, device_ident, now_ts, beacon_key),
                )
                conn.commit()
                conn.close()
                return jsonify({"status": "ignored", "reason": "state_mismatch"}), 200

            last_still_ts = int(row[2] or 0) if row else 0
            if last_still_ts and (now_ts - last_still_ts) < 600:
                conn.close()
                return jsonify({"status": "ignored", "reason": "throttled"}), 200

            conn.execute(
                "INSERT INTO notifications (type, beacon_name, event_time, distance, created_at, beacon_id, device_ident) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (ntype, name, event_time, distance, created_at, beacon_id, device_ident),
            )

            if row:
                conn.execute(
                    "UPDATE beacon_states SET last_still_ts = ? WHERE beacon_key = ?",
                    (now_ts, beacon_key),
                )
            else:
                conn.execute(
                    "INSERT INTO beacon_states (beacon_key, state, last_change_ts, last_still_ts, device_ident, last_seen_ts, active) VALUES (?, ?, ?, NULL, ?, ?, 1)",
                    (beacon_key, desired_state, now_ts, device_ident, now_ts),
                )

            conn.commit()
            conn.close()
            return jsonify({"status": "ok"}), 201

    # ---- Default: store other event types as-is (no dedupe) ----
    conn.execute(
        "INSERT INTO notifications (type, beacon_name, event_time, distance, created_at, beacon_id, device_ident) VALUES (?, ?, ?, ?, ?, ?, ?)",
        (ntype, name, event_time, distance, created_at, beacon_id, device_ident),
    )
    conn.commit()
    conn.close()
    return jsonify({"status": "ok"}), 201


# ---- Reports history & downloads ----

@app.route("/reports/history", methods=["GET"])
def reports_history():
    """
    Simple page showing daily_reports history.
    """
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS daily_reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            created_at TEXT,
            pdf_path TEXT,
            report_json TEXT,
            summary TEXT
        )
        """
    )
    rows = conn.execute(
        "SELECT id, created_at, summary FROM daily_reports ORDER BY id DESC LIMIT 200"
    ).fetchall()
    conn.close()
    return render_template("reports_history.html", reports=rows)


@app.route("/notifications/history", methods=["GET"])
def notifications_history():
    """
    Page showing notifications history with a simple search bar.
    """
    q = (request.args.get("q") or "").strip()
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            type TEXT,
            beacon_name TEXT,
            event_time TEXT,
            distance REAL,
            created_at TEXT
        )
        """
    )

    # Map beacon ids and friendly names onto a single display label
    alias = build_beacon_alias_map(conn)

    if q:
        like = f"%{q}%"
        rows_raw = conn.execute(
            """
            SELECT id, type, beacon_name, event_time, distance, created_at
            FROM notifications
            WHERE type IN ('in', 'left', 'still_in', 'still_out')
              AND (beacon_name LIKE ? OR type LIKE ? OR event_time LIKE ? OR created_at LIKE ?)
            ORDER BY id DESC
            LIMIT 500
            """,
            (like, like, like, like),
        ).fetchall()
    else:
        rows_raw = conn.execute(
            """
            SELECT id, type, beacon_name, event_time, distance, created_at
            FROM notifications
            WHERE type IN ('in', 'left', 'still_in', 'still_out')
            ORDER BY id DESC
            LIMIT 500
            """
        ).fetchall()

    # Apply alias map so the same beacon (ID vs renamed) looks like one thing
    rows = []
    for rid, rtype, bname, event_time, distance, created_at in rows_raw:
        display_name = alias.get(bname, bname or "Unknown")
        rows.append((rid, rtype, display_name, event_time, distance, created_at))

    conn.close()
    return render_template("notifications_history.html", notifications=rows, query=q)
@app.route("/uptime", methods=["GET"])
def uptime_page():
    """
    Simple page showing recent system health snapshots from uptime_logs.
    """
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS uptime_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            device_count INTEGER,
            beacon_count INTEGER,
            status TEXT
        )
        """
    )
    rows = conn.execute(
        """
        SELECT id, timestamp, device_count, beacon_count, status
        FROM uptime_logs
        ORDER BY id DESC
        LIMIT 500
        """
    ).fetchall()
    conn.close()

    return render_template("uptime.html", logs=rows)



@app.route("/download/latest-report", methods=["GET"])
def download_latest_report():
    """
    Download the most recent daily report PDF.
    """
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS daily_reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            created_at TEXT,
            pdf_path TEXT,
            report_json TEXT,
            summary TEXT
        )
        """
    )
    row = conn.execute(
        "SELECT id, pdf_path FROM daily_reports ORDER BY id DESC LIMIT 1"
    ).fetchone()
    conn.close()

    if not row or not row[1] or not os.path.exists(row[1]):
        return "No reports available yet.", 404

    pdf_path = row[1]
    filename = os.path.basename(pdf_path)
    return send_file(pdf_path, as_attachment=True, download_name=filename)


@app.route("/download/report/<int:report_id>", methods=["GET"])
def download_report(report_id):
    """
    Download a specific report PDF by id.
    """
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS daily_reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            created_at TEXT,
            pdf_path TEXT,
            report_json TEXT,
            summary TEXT
        )
        """
    )
    row = conn.execute(
        "SELECT pdf_path FROM daily_reports WHERE id = ?",
        (report_id,),
    ).fetchone()
    conn.close()

    if not row or not row[0] or not os.path.exists(row[0]):
        return "Report not found.", 404

    pdf_path = row[0]
    filename = os.path.basename(pdf_path)
    return send_file(pdf_path, as_attachment=True, download_name=filename)


# ---- Activity reports page ----


@app.route("/activity-reports", methods=["GET", 'POST'])  # noqa: E501
def activity_reports():
    """
    Page to generate and list activity reports for individual beacons or whole devices.
    """
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS activity_reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            beacon_name TEXT,
            pdf_path TEXT,
            created_at TEXT,
            summary TEXT
        )
        """
    )
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            type TEXT,
            beacon_name TEXT,
            event_time TEXT,
            distance REAL,
            created_at TEXT
        )
        """
    )
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS devices (
            id TEXT PRIMARY KEY,
            name TEXT,
            color TEXT
        )
        """
    )
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS beacon_names (
            id TEXT PRIMARY KEY,
            name TEXT
        )
        """
    )

    if request.method == "POST":
        report_kind = (request.form.get("report_kind") or "beacon").strip()
        start_date = (request.form.get("start_date") or "").strip()
        end_date = (request.form.get("end_date") or "").strip()

        if report_kind == "device":
            device_ident = (request.form.get("device_ident") or "").strip()
            if device_ident:
                generate_device_activity_report(device_ident, start_date or None, end_date or None)
        else:
            beacon_key = (request.form.get("beacon_id") or "").strip()
            if beacon_key:
                generate_activity_report(beacon_key, start_date or None, end_date or None)

        return redirect(url_for("activity_reports"))

    # ---- Build beacon dropdown with unified labels (ID + rename merged) ----
    rows_beacon_meta = conn.execute("SELECT id, name FROM beacon_names").fetchall()
    id_to_label = {}
    known_ids = set()
    known_names = set()
    for bid, bname in rows_beacon_meta:
        if not bid:
            continue
        known_ids.add(bid)
        if bname:
            known_names.add(bname)
        if bname and bname != bid:
            label = f"{bname} ({bid})"
        else:
            label = bid
        id_to_label[bid] = label

    rows_beacons = conn.execute(
        "SELECT DISTINCT beacon_name FROM notifications WHERE beacon_name IS NOT NULL ORDER BY beacon_name"
    ).fetchall()
    beacon_strings = [r[0] for r in rows_beacons if r[0]]

    beacon_options = []
    # First: every known beacon id with its combined label
    for bid in sorted(id_to_label.keys(), key=lambda x: id_to_label[x].lower()):
        beacon_options.append({"ident": bid, "label": id_to_label[bid]})

    # Then: any notification names that were never renamed at all
    for name in beacon_strings:
        if name in known_ids or name in known_names:
            continue
        beacon_options.append({"ident": name, "label": name})

    # ---- Build device dropdown options ----
    device_rows = conn.execute("SELECT id, name FROM devices").fetchall()
    device_options = []
    seen_device_ids = set()
    for did, dname in device_rows:
        if not did or did in seen_device_ids:
            continue
        seen_device_ids.add(did)
        label = f"{dname} ({did})" if dname and dname != did else did
        device_options.append({"ident": did, "label": label})

    # Include any in-memory devices that might not yet be in the devices table
    for ident in sorted(latest_messages.keys()):
        if ident == "DAILY_REPORT" or ident in seen_device_ids:
            continue
        device_options.append({"ident": ident, "label": ident})
        seen_device_ids.add(ident)

    # Existing activity reports history
    rows_reports = conn.execute(
        "SELECT id, beacon_name, created_at, summary FROM activity_reports ORDER BY id DESC LIMIT 200"
    ).fetchall()
    conn.close()

    return render_template(
        "activity_reports.html",
        beacons=beacon_options,
        devices=device_options,
        reports=rows_reports,
    )

@app.route("/timeline", methods=["GET"])
def beacon_timeline():
    """Per-beacon activity timeline page, built from notifications history."""
    beacon_key = (request.args.get("beacon") or "").strip()
    start_date = (request.args.get("start_date") or "").strip()
    end_date = (request.args.get("end_date") or "").strip()

    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            type TEXT,
            beacon_name TEXT,
            event_time TEXT,
            distance REAL,
            created_at TEXT
        )
        """
    )
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS beacon_names (
            id TEXT PRIMARY KEY,
            name TEXT
        )
        """
    )

    # Build beacon dropdown in the same way as activity_reports
    rows_beacon_meta = conn.execute("SELECT id, name FROM beacon_names").fetchall()
    id_to_label = {}
    known_ids = set()
    known_names = set()
    for bid, bname in rows_beacon_meta:
        if not bid:
            continue
        known_ids.add(bid)
        if bname:
            known_names.add(bname)
        if bname and bname != bid:
            label = f"{bname} ({bid})"
        else:
            label = bid
        id_to_label[bid] = label

    rows_beacons = conn.execute(
        "SELECT DISTINCT beacon_name FROM notifications WHERE beacon_name IS NOT NULL ORDER BY beacon_name"
    ).fetchall()
    beacon_strings = [r[0] for r in rows_beacons if r[0]]

    beacon_options = []
    for bid in sorted(id_to_label.keys(), key=lambda x: id_to_label[x].lower()):
        beacon_options.append({"ident": bid, "label": id_to_label[bid]})
    for name in beacon_strings:
        if name in known_ids or name in known_names:
            continue
        beacon_options.append({"ident": name, "label": name})

    # Work out which raw names in notifications should be treated as the selected beacon
    beacon_id = None
    friendly_name = None
    for bid, bname in rows_beacon_meta:
        if beacon_key == bid or (bname and beacon_key == bname):
            beacon_id = bid
            friendly_name = bname
            break

    names_to_match = []
    if beacon_id:
        names_to_match.append(beacon_id)
        if friendly_name and friendly_name != beacon_id:
            names_to_match.append(friendly_name)
    elif beacon_key:
        names_to_match.append(beacon_key)

    events = []
    if names_to_match:
        where_clauses = []
        params = []

        if len(names_to_match) == 1:
            where_clauses.append("beacon_name = ?")
            params.append(names_to_match[0])
        else:
            placeholders = ", ".join("?" for _ in names_to_match)
            where_clauses.append(f"beacon_name IN ({placeholders})")
            params.extend(names_to_match)

        if start_date:
            start_iso = f"{start_date} 00:00:00"
            where_clauses.append("REPLACE(event_time, 'T', ' ') >= ?")
            params.append(start_iso)
        if end_date:
            end_iso = f"{end_date} 23:59:59"
            where_clauses.append("REPLACE(event_time, 'T', ' ') <= ?")
            params.append(end_iso)

        sql = (
            "SELECT id, type, event_time, distance, created_at "
            "FROM notifications WHERE " + " AND ".join(where_clauses) +
            " ORDER BY event_time ASC, id ASC"
        )
        events = conn.execute(sql, params).fetchall()

    conn.close()
    return render_template(
        "timeline.html",
        beacons=beacon_options,
        selected_beacon=beacon_key,
        events=events,
        start_date=start_date,
        end_date=end_date,
    )

@app.route("/analytics", methods=["GET"])
def analytics_dashboard():
    """Analytics dashboard showing uptime, status breakdown, and beacon activity."""
    conn = get_db()

    # Define a rolling window (last 24 hours) for analytics
    now_ts = time.time()
    window_hours = 24
    window_start_ts = now_ts - window_hours * 3600
    # Use Samoa-local timestamps so they match what we store in the DB
    uptime_from = format_samoa_time(window_start_ts)
    notif_from = format_samoa_time(window_start_ts)

    # Uptime data
    try:
        uptime_rows = conn.execute(
            """
            SELECT timestamp, device_count, beacon_count, status
            FROM uptime_logs
            WHERE timestamp >= ?
            ORDER BY timestamp ASC
            """,
            (uptime_from,),
        ).fetchall()
    except Exception:
        uptime_rows = []

    uptime_labels = []
    device_counts = []
    beacon_counts = []
    status_counts = {}
    for ts, devc, beac, status in uptime_rows:
        uptime_labels.append(ts)
        device_counts.append(devc or 0)
        beacon_counts.append(beac or 0)
        key = status or "UNKNOWN"
        status_counts[key] = status_counts.get(key, 0) + 1

    # Build status breakdown table (status, count, percent)
    total_status = sum(status_counts.values())
    status_breakdown = []
    if total_status > 0:
        for status_key, count in sorted(status_counts.items(), key=lambda kv: kv[0]):
            percent = round(count * 100.0 / total_status, 1)
            status_breakdown.append({
                'status': status_key,
                'count': count,
                'percent': percent,
            })
    else:
        status_breakdown = []

    # Notifications data in the same window
    try:
        notif_rows = conn.execute(
            """
            SELECT beacon_name, type, event_time
            FROM notifications
            WHERE event_time >= ?
              AND type IN ('in', 'left')
            ORDER BY event_time ASC
            """,
            (notif_from,),
        ).fetchall()

    except Exception:
        notif_rows = []

    conn.close()
    beacon_activity = {}
    beacon_in_counts = {}
    beacon_left_counts = {}
    hourly_buckets = {}  # hour label -> count
    presence_summary = []

    # Group events per beacon so we can also compute time-in-range metrics
    per_beacon_events = {}  # name -> list[(type, event_time)]

    for beacon_name, typ, event_time in notif_rows:
        name = beacon_name or "Unknown"
        beacon_activity[name] = beacon_activity.get(name, 0) + 1
        if typ == "in":
            beacon_in_counts[name] = beacon_in_counts.get(name, 0) + 1
        elif typ == "left":
            beacon_left_counts[name] = beacon_left_counts.get(name, 0) + 1

        # Track raw events for presence computation
        per_beacon_events.setdefault(name, []).append((typ, event_time or ""))

        # Hourly distribution for notifications
        event_time = (event_time or "").strip()
        if event_time:
            # Normalise to the "YYYY-MM-DD HH:MM:SS" pattern (older rows may contain a 'T')
            normalized = event_time.replace("T", " ")
            try:
                tm = time.strptime(normalized[:19], "%Y-%m-%d %H:%M:%S")
                hour_label = time.strftime("%H:00", tm)
                hourly_buckets[hour_label] = hourly_buckets.get(hour_label, 0) + 1
            except Exception:
                # Ignore rows with unexpected time format
                pass

    # Build per-beacon presence summary (in-range vs out-of-range %)
    if notif_rows:
        # Same 24h window we used for fetching notif_rows
        window_start_label = notif_from
        window_end_label = format_samoa_time(now_ts)
        for name, events in per_beacon_events.items():
            # Presence calculations should never take down the whole analytics page.
            # Some historical rows may contain unexpected timestamps; treat those beacons as "no data".
            try:
                presence = compute_presence_stats(events, window_start_label, window_end_label)
            except Exception:
                presence = None
            if presence:
                in_hours = presence["in_seconds"] / 3600.0
                out_hours = presence["out_seconds"] / 3600.0
                presence_summary.append({
                    "name": name,
                    "in_percent": presence["in_percent"],
                    "out_percent": presence["out_percent"],
                    "in_hours": round(in_hours, 1),
                    "out_hours": round(out_hours, 1),
                    "in_seconds": presence["in_seconds"],
                    "out_seconds": presence["out_seconds"],
                    "last_state": (events[-1][0] if events else None),
                    "last_event_time": (events[-1][1] if events else None),
                    "event_count": len(events),
                })

    # Sort presence summary by highest in-range percentage
    presence_summary.sort(key=lambda p: (-p["in_percent"], p["name"]))
    # Presence lookup for dropdown + donut chart
    presence_by_beacon = {p["name"]: p for p in presence_summary}
    selected_beacon = request.args.get("beacon") or (presence_summary[0]["name"] if presence_summary else "")
    selected_presence = presence_by_beacon.get(selected_beacon) if selected_beacon else None

    # Uptime OK percentage (how often status=OK in the window)
    uptime_ok_percent = round(status_counts.get("OK", 0) * 100.0 / total_status, 1) if total_status else 0.0

    # Most active beacon (by IN/LEFT count)
    most_active_beacon = max(beacon_activity.items(), key=lambda kv: kv[1])[0] if beacon_activity else ""


    # Top beacons by total events for chart/table display
    if beacon_activity:
        sorted_beacons = sorted(beacon_activity.items(), key=lambda kv: (-kv[1], kv[0]))
        beacon_labels = [name for name, _ in sorted_beacons]
        beacon_totals = [beacon_activity[name] for name in beacon_labels]
        beacon_ins = [beacon_in_counts.get(name, 0) for name in beacon_labels]
        beacon_lefts = [beacon_left_counts.get(name, 0) for name in beacon_labels]
    else:
        beacon_labels = []
        beacon_totals = []
        beacon_ins = []
        beacon_lefts = []

    # Top beacons by total events for chart/table display

    # Hourly distribution for notifications
    hourly_labels = sorted(hourly_buckets.keys())
    hourly_counts = [hourly_buckets[h] for h in hourly_labels]

    # Latest uptime snapshot summary
    if uptime_rows:
        latest_ts, latest_devices, latest_beacons, latest_status = uptime_rows[-1]
        latest_devices = latest_devices or 0
        latest_beacons = latest_beacons or 0
    else:
        latest_ts = None
        latest_devices = 0
        latest_beacons = 0
        latest_status = "NO_DATA"

    total_events = len(notif_rows)

    return render_template(
        "analytics.html",
        window_hours=window_hours,
        uptime_labels=uptime_labels,
        device_counts=device_counts,
        beacon_counts=beacon_counts,
        status_breakdown=status_breakdown,
        hourly_labels=hourly_labels,
        hourly_counts=hourly_counts,
        beacon_labels=beacon_labels,
        beacon_totals=beacon_totals,
        beacon_ins=beacon_ins,
        beacon_lefts=beacon_lefts,
        presence_summary=presence_summary,
        presence_by_beacon_json=json.dumps(presence_by_beacon),
        selected_beacon=selected_beacon,
        selected_presence=selected_presence,
        uptime_ok_percent=uptime_ok_percent,
        most_active_beacon=most_active_beacon,
        latest_devices=latest_devices,
        latest_beacons=latest_beacons,
        latest_status=latest_status,
        latest_timestamp=latest_ts,
        total_events=total_events,
    )

@app.route("/download/activity-report/<int:report_id>", methods=["GET"])
def download_activity_report(report_id):
    """
    Download a specific activity report PDF by id.
    """
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS activity_reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            beacon_name TEXT,
            pdf_path TEXT,
            created_at TEXT,
            summary TEXT
        )
        """
    )
    row = conn.execute(
        "SELECT pdf_path FROM activity_reports WHERE id = ?",
        (report_id,),
    ).fetchone()
    conn.close()

    if not row or not row[0] or not os.path.exists(row[0]):
        return "Activity report not found.", 404

    pdf_path = row[0]
    filename = os.path.basename(pdf_path)
    return send_file(pdf_path, as_attachment=True, download_name=filename)


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)


# ===============================
# INTERNAL EVALUATION ENDPOINT
# ===============================
from flask import request, abort, jsonify
import os
from cron_evaluator import main as evaluate_once

@app.route("/internal/evaluate", methods=["POST"])
def internal_evaluate():
    if request.headers.get("X-Internal-Secret") != os.getenv("INTERNAL_SECRET"):
        abort(403)

    try:
        evaluate_once()
        return jsonify({"status": "ok"}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500



# === Background Evaluator (Single Service Mode) ===
import threading, time, os
from cron_evaluator import run_evaluator

def evaluator_loop():
    print("üîÑ Background evaluator started")
    while True:
        try:
            run_evaluator()
        except Exception as e:
            print("‚ùå Evaluator error:", e)
        time.sleep(60)

if os.environ.get("EVALUATOR_STARTED") != "1":
    os.environ["EVALUATOR_STARTED"] = "1"
    threading.Thread(target=evaluator_loop, daemon=True).start()
# === End Background Evaluator ===
